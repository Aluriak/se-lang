"""Routines to build model from ASP data"""

import clyngor
import itertools
from .objects import (Model, Orbit, OBJECTS, OBJECTS_NAME, RING_ARGS_ORDER, ORBIT_ARGS_ORDER,
                      STAR_ARGS_ORDER, PLANET_ARGS_ORDER, BARY_ARGS_ORDER)
from .objects_builder import (ref, ring as ring_builder, planet as planet_builder,
                              star as star_builder, barycenter as bary_builder)
from .commons import asp_value_to_pyvalue



# rebuild all with specific uids
_gen_uid = itertools.count(1)
gen_uid = lambda: next(_gen_uid)


def data(fname:str) -> [dict]:
    """Yield the extracted data from given file"""
    # do not parse int, so that uids in ASP code are all strings,
    #  therefore they cannot collide with those generated by gen_uid()
    yield from clyngor.solve(fname).by_predicate.parse_args.careful_parsing.int_not_parsed


def root_info(asp_model, objects:dict) -> (str, str, ...):
    """Return the root uid, the system name, and data to be given
    to populate_orbits function.

    asp_model -- dictionnary containing definition of asp atoms
    objects -- dict. Modified, so root_uid maps to the root definition.

    """
    roots = tuple(args for args in asp_model.get('system', ()) if len(args) >= 2)
    if len(roots) > 1:
        print('Multiple roots. Bad.')
        exit(1)
    elif len(roots) == 1:
        format_ = lambda x: str(x).strip('"')
        args = tuple(map(format_, roots[0]))
        if len(args) == 2:
            root_uid, system_name = args
        else:
            raise ValueError("Expect a system/2 atom, not '{}'".format(args))
    else:
        print('No root. Bad.')
        exit(1)  # TODO: determine the root by yourself

    aspuids = _populate_objects(asp_model, objects)  # side effect
    if root_uid not in aspuids:
        assert root_uid not in objects
        aspuids[root_uid] = root_uid
        objects[root_uid] = ref(root_uid)
    return aspuids[root_uid], system_name, aspuids


def populate_orbits(asp_model, orbits:list, objects:dict, root_uid:str, aspuids:dict):
    for args in asp_model.get('orbit', ()):
        if len(args) >= 3:
            gen_orbits(args, objects, orbits, aspuids)
        else:
            raise ValueError('Non valid: {}'.format(args))


def gen_orbits(args:tuple, objects:dict, orbits:list, aspuids:dict) -> int:
    """Populate given orbits, return parent uid"""
    parent, child, orbit_params, *properties = args

    # Compute orbit parameters
    if isinstance(orbit_params, (str, int)):
        orbit_params_map = {'semimajoraxis': asp_value_to_pyvalue(orbit_params)}
    elif not isinstance(orbit_params, tuple) or len(orbit_params) != 2:
        raise ValueError("Unexpected orbit parameters: {}".format(orbit_params))
    else:  # it's a valid atom tuple !
        predicat, orbit_params = orbit_params
        orbit_params_map = {
            k: asp_value_to_pyvalue(v)
            for k, v in dict(zip(ORBIT_ARGS_ORDER, orbit_params)).items()
        }
    distance = orbit_params_map['semimajoraxis']  # shortcut
    properties = set(properties)
    retrograde = 'retrograde' in map(lambda s: s.strip('"'), properties)
    orbit_info = Orbit(retrograde=retrograde, **orbit_params_map)

    # normalize parent
    if isinstance(parent, tuple) and parent[0] in OBJECTS_NAME:
        parent_uid = gen_uid()
        parent = _asp_tuple_to_object(parent)
        objects[parent_uid] = parent
    elif isinstance(parent, str) and parent in aspuids:  # id
        parent_uid, parent = aspuids[parent], objects[aspuids[parent]]
    elif isinstance(parent, int) and parent in objects:  # id
        parent_uid, parent = parent, objects[parent]
    elif isinstance(parent, str):
        parent_uid, parent = parent, ref(parent)
    else:
        raise ValueError("Unknow type (is/2) for parent element of uid {}".format(parent))

    # Compute objects representation if available
    if isinstance(child, tuple) and child[0] in OBJECTS_NAME:
        child_uid = gen_uid()
        child = _asp_tuple_to_object(child)
        objects[child_uid] = child
    elif isinstance(child, tuple) and child[0] == 'orbit':
        direct_child = child[1][0]
        # generate the subtree
        # print('RECURSIVE CALL WITH:', child[1], objects, orbits)
        direct_child_uid = gen_orbits(child[1], objects, orbits, aspuids)
        assert direct_child_uid in objects
        # make the link between parent and immediate child
        subargs = (args[0], direct_child_uid, *args[2:])
        # print('RECURSIVE CALL WITH:', subargs, objects, orbits)
        return gen_orbits(subargs, objects, orbits, aspuids)
    elif isinstance(child, str) and child in aspuids:  # id
        child_uid, child = aspuids[child], objects[aspuids[child]]
    elif isinstance(child, int) and child in objects:  # id
        child_uid, child = child, objects[child]
    elif isinstance(child, str):
        child_uid, child = child, ref(child)
    else:
        raise ValueError("Unknow type (is/2) for child element of uid {}".format(child))

    # determine behavior based on child expression
    if type(child) in OBJECTS | {str} and type(parent) in OBJECTS | {str}:
        orbits.append((parent_uid, child_uid, orbit_info))
        objects[parent_uid] = parent
        objects[child_uid] = child
    else:
        raise ValueError("Non handlable orbit data '{}' (understood as '{}')"
                         "".format(args, (parent, child, distance, properties)))
    if not (parent_uid in objects or parent_uid in aspuids):
        print('PARENT UID:', parent_uid)
        print('OBJECTS:', objects)
        print('ASPUIDS:', aspuids)
        assert False, "somewhere, objects and aspuids are not handled properly"

    return parent_uid


def _populate_objects(asp_model, objects:dict) -> dict:
    """Populate given objects dict and return a map from asp uid to global uid"""
    aspuids = {}  # aspuid -> newuid
    for args in asp_model.get('is', ()):
        if len(args) == 2:
            uid, obj = args
            if uid in objects:
                raise ValueError("UID {} given multiple (at least two) times. "
                                 "One for '{}', One for '{}'."
                                 "".format(uid, objects[uid], obj))
            newuid = gen_uid()
            aspuids[uid] = newuid
            if isinstance(obj, tuple):
                obj_repr = _asp_tuple_to_object(obj)
                objects[newuid] = obj_repr
            elif isinstance(obj, str):
                objects[newuid] = ref(obj)
            else:
                raise ValueError("is/2 atom provides a non-handlable object of type {}: {}"
                                 "".format(type(obj), obj))
    return aspuids

def _asp_tuple_to_object(atom:tuple) -> object:
    """Return the object equivalent of given planet or star in ASP"""
    assert isinstance(atom, tuple) and atom[0] in OBJECTS_NAME
    if atom[0] == 'planet':
        builder, args_order = planet_builder, PLANET_ARGS_ORDER
    elif atom[0] == 'star':
        builder, args_order = star_builder, STAR_ARGS_ORDER
    elif atom[0] == 'ring':
        builder, args_order = ring_builder, RING_ARGS_ORDER
    elif atom[0] == 'barycenter':
        builder, args_order = bary_builder, BARY_ARGS_ORDER
    elif atom[0] in OBJECTS_NAME:
        raise ValueError("Non handled object {}".format(atom[0]))
    else:
        raise ValueError("Atom {} do not encode any known object".format(atom))
    data = dict(zip(args_order, map(asp_value_to_pyvalue, atom[1])))
    return builder(**data)
